
"""
Student information for this assignment:

Replace <FULL NAME> with your name.
On my/our honor, <Anika Koppula> and <Saisrikar Kichili>, this
programming assignment is my own work and I have not provided this code to
any other student.

I have read and understand the course syllabus's guidelines regarding Academic
Integrity. I understand that if I violate the Academic Integrity policy (e.g.
copy code from someone else, have the code generated by an LLM, or give my
code to someone else), the case shall be submitted to the Office of the Dean of
Students. Academic penalties up to and including an F in the course are likely.

UT EID 1: ark3398
UT EID 2: srk2749
"""



class Node:
    """
    Represents a node in a singly linked list.

    Instance Variables:
        data: The value or data stored in the node.
        next: The reference to the next node in the linked list (None by default).
    """

    def __init__(self, data, next=None):
        """
        Initializes a new node with the given data and a reference to the next node.

        Args:
            data: The data to store in the node.
            next: Optional; the next node in the linked list (None by default).
        """
        self.data = data
        self.next = next


class StackError(Exception):
    """
    A class
    """


class Stack:
    """
    A class
    """
    def __init__(self):
        self._top = None
        self._size = 0

    def peek(self):
        """
        A function
        """
        if self.is_empty():
            raise StackError("Peek from empty stack.")
        return self._top.data

    def push(self, item):
        """
        A function
        """
        new_node = Node(item)
        new_node.next = self._top
        self._top = new_node
        self._size += 1

    def pop(self):
        """
        A function
        """
        if self.is_empty():
            raise StackError("Pop from empty stack.")
        removed_data = self._top.data
        self._top = self._top.next
        self._size -= 1
        return removed_data

    def is_empty(self):
        """
        A function
        """
        return self._top is None

    def size(self):
        """
        A function
        """
        return self._size


class QueueError(Exception):
    """
    A class
    """


class Queue:
    """
    A class that implements a queue using a singly linked list with a tail.

    Instance Variables:
        _front: The beginning node of the queue.
        _rear: The end node of the queue.
        _size: The number of elements in the queue.
    """

    def __init__(self):
        """
        Initializes an empty queue with no elements.
        """
        self._front = None
        self._rear = None
        self._size = 0

    def peek(self):
        """
        Returns the value at the front of the queue without removing it.

        Raises:
            QueueError: If the queue is empty, raises "Peek from empty queue.".

        Returns:
            The data stored in the front node of the queue.
        """
        if self.is_empty():
            raise QueueError("Peek from empty queue.")
        return self._front.data

    def enqueue(self, item):
        """
        Enqueues a new item at the end of the queue.

        Args:
            item: The data to put at the end of queue.
        """
        new_node = Node(item)
        if self.is_empty():
            self._front = new_node
        else:
            self._rear.next = new_node
        self._rear = new_node
        self._size += 1

    def dequeue(self):
        """
        Removes and returns the item at the front of the queue.

        Raises:
            QueueError: If the queue is empty, raises "Dequeue from empty queue.".

        Returns:
            The data from the front node of the queue.
        """
        if self.is_empty():
            raise QueueError("Dequeue from empty queue.")
        front_data = self._front.data
        self._front = self._front.next
        if self._front is None:  # If queue becomes empty
            self._rear = None
        self._size -= 1
        return front_data

    def is_empty(self):
        """
        Checks if the queue is empty.

        Returns:
            True if the queue is empty, False otherwise.
        """
        return self._size == 0

    def size(self):
        """
        Returns the number of items in the queue.

        Returns:
            The size of the queue as an integer.
        """
        return self._size


class Vertex:
    """Vertex Class using properties and setters for better encapsulation."""

    def __init__(self, label):
        self.__label = label
        self.visited = False

    @property
    def visited(self):
        """Property to get the visited status of the vertex."""
        return self.__visited

    @visited.setter
    def visited(self, value):
        """Setter to set the visited status of the vertex."""
        if isinstance(value, bool):
            self.__visited = value
        else:
            raise ValueError("Visited status must be a boolean value.")

    @property
    def label(self):
        """Property to get the label of the vertex."""
        return self.__label

    def __str__(self):
        """String representation of the vertex"""
        return str(self.__label)


class Graph:
    """A Class to present Graph."""

    def __init__(self):
        self.vertices = []  # a list of vertex objects
        self.adjacency_matrix = []  # adjacency matrix of edges

    def has_vertex(self, label):
        """Check if a vertex is already in the graph"""
        for i in self.vertices:
            if i.label == label:
                return True
        return False

    def get_index(self, label):
        """Given a label get the index of a vertex"""
        for i in range(len(self.vertices)):
            if self.vertices[i].label == label:
                return i
        return -1

    def add_vertex(self, label):
        """Add a Vertex with a given label to the graph"""
        if self.has_vertex(label):
            return
        self.vertices.append(Vertex(label))
        for i in self.adjacency_matrix:
            i.append(0)
        self.adjacency_matrix.append([0] * len(self.vertices))

    def add_edge(self, start, finish):
        """Add unweighted directed edge to graph"""
        self.adjacency_matrix[start][finish] = 1

    def get_adjacent_vertices(self, vertex_index):
        """Return adjacent vertex indices to vertex_index"""
        vertices = []
        for i in range(len(self.vertices)):
            if self.adjacency_matrix[vertex_index][i] == 1:
                vertices.append(i)
        return vertices
    def has_cycle(self):
        """
        A function
        """
        go = [False] * len(self.vertices)
        x = [False] * len(self.vertices)
        def helper(y):
            go[y] = True
            x[y] = True
            for i in self.get_adjacent_vertices(y):
                if not go[i]:
                    if helper(i):
                        return True
                elif x[i]:
                    return True
            x[y] = False
            return False
        
        for i in range(len(self.vertices)):
            if not go[i]:
                if helper(i):
                    return True
        return False


    def get_registration_plan(self):
        """
        Return a valid ordering of courses to take for registration as a 2D
        list of vertex labels, where each inner list will be a maximum of 4.

        pre: a valid registration plan exists.
        post: returns a 2D list of strings, where each inner list represents a semester
        """

        # Because we don't want to destroy the original graph,
        # we have defined helper functions that work with a copy of the
        # adjacency matrix and vertices. This is also a hint that we
        # suggest you to manipulate the graph copy to solve this method.
        temp_vertices = list(self.vertices)
        temp_matrix = [list(row) for row in self.adjacency_matrix]

        def get_index_from_copy(label, vertices_copy):
            """Given a label get the index of a vertex in the copy of the vertices list"""
            num_vertices = len(vertices_copy)
            for i in range(num_vertices):
                if label == vertices_copy[i].label:
                    return i
            return -1

        def delete_vertex_from_copy(vertex_label, adjacency_matrix_copy, vertices_copy):
            """delete vertex from the copy of the adjacency matrix and vertices list"""
            index = get_index_from_copy(vertex_label, vertices_copy)

            for row in adjacency_matrix_copy:
                row.pop(index)
            adjacency_matrix_copy.pop(index)
            vertices_copy.pop(index)
        courses = []
        prereq = [0] * len(temp_vertices)
        for i in range(len(temp_vertices)):
            for j in range(len(temp_matrix[i])):
                if temp_matrix[i][j] == 1:
                    prereq[j] += 1
        noprereq = [temp_vertices[i] for i in range(len(temp_vertices)) if prereq[i] == 0]
        while noprereq:
            sem = []
            for i in range(min(4, len(noprereq))):
                course = noprereq.pop(0)
                sem.append(course.label)
                delete_vertex_from_copy(course.label, temp_matrix, temp_vertices)
            courses.append(sem)
            prereq = [0] * len(temp_vertices)
            for i in range(len(temp_vertices)):
                for j in range(len(temp_matrix[i])):
                    if temp_matrix[i][j] == 1:
                        prereq[j] += 1
            xnoprereq = [temp_vertices[i] for i in range(len(temp_vertices))
                      if prereq[i] == 0 and temp_vertices[i] not in noprereq]
            noprereq.extend(xnoprereq)
        return courses

def main():
    """
    The main function to retrieve a registration plan.
    The output code has been written for you.
    """

    # create a Graph object
    graph = Graph()

    # read the number of vertices
    vertices = ["CS303E", "CS313E",
                "CS323E", "CS324E", 
                "CS326E", "CS327E", 
                "CS329E", "CS330E", 
                "CS331E"]

    # read the vertices and add them into the graph
    for course in vertices:
        graph.add_vertex(course)

    # read the number of edges
    edges = [("CS303E", "CS313E"),
        ("CS313E", "CS323E"),
        ("CS313E", "CS324E"),
        ("CS313E", "CS326E"),
        ("CS313E", "CS327E"),
        ("CS313E", "CS329E"),
        ("CS313E", "CS330E"),
        ("CS330E", "CS331E")]
    # read the edges and insert them into the graph
    # you will need to call the method to convert them from their labels to their index
    for prereq, course in edges:
        prereq_index = vertices.index(prereq)
        course_index = vertices.index(course)
        graph.add_edge(prereq_index, course_index)
    ####################################################################################
    # DO NOT CHANGE ANYTHING BELOW THIS
    if graph.has_cycle():
        print("Registration plan invalid because a cycle was detected.")
    else:
        print("Valid registration plan detected.")

        courses = graph.get_registration_plan()
        print()
        print("Registration plan: ")
        for semester in courses:
            print(semester)

if __name__ == "__main__":
    main()
